// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: rpc/service.proto

import {
  BinaryReader,
  BinaryWriter,
  JSONrequest,
  PBrequest,
} from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running `yarn twirpscript`.
export { MIN_SUPPORTED_VERSION_0_0_49 } from "twirpscript";

//========================================//
//  GroupMeetingService Protobuf Client   //
//========================================//

export async function GetGroupEvent(getGroupEventReq, config) {
  const response = await PBrequest(
    "/GroupMeetingService/GetGroupEvent",
    GetGroupEventReq.encode(getGroupEventReq),
    config
  );
  return GetGroupEventRes.decode(response);
}

/**
 * Updates the attendee’s availability. When all attendees have entered their availability, emits a request to create a calendar event to the Calendar Event management lambda
 */
export async function UpdateGroupEvent(updateGroupEventReq, config) {
  const response = await PBrequest(
    "/GroupMeetingService/UpdateGroupEvent",
    UpdateGroupEventReq.encode(updateGroupEventReq),
    config
  );
  return UpdateGroupEventRes.decode(response);
}

//========================================//
//    GroupMeetingService JSON Client     //
//========================================//

export async function GetGroupEventJSON(getGroupEventReq, config) {
  const response = await JSONrequest(
    "/GroupMeetingService/GetGroupEvent",
    getGroupEventReq,
    config
  );
  return response;
}

/**
 * Updates the attendee’s availability. When all attendees have entered their availability, emits a request to create a calendar event to the Calendar Event management lambda
 */
export async function UpdateGroupEventJSON(updateGroupEventReq, config) {
  const response = await JSONrequest(
    "/GroupMeetingService/UpdateGroupEvent",
    updateGroupEventReq,
    config
  );
  return response;
}

export function createGroupMeetingService(service) {
  return {
    name: "GroupMeetingService",
    methods: {
      GetGroupEvent: {
        name: "GetGroupEvent",
        handler: service.GetGroupEvent,
        input: GetGroupEventReq,
        output: GetGroupEventRes,
      },
      UpdateGroupEvent: {
        name: "UpdateGroupEvent",
        handler: service.UpdateGroupEvent,
        input: UpdateGroupEventReq,
        output: UpdateGroupEventRes,
      },
    },
  };
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const GetGroupEventReq = {
  /**
   * Serializes a GetGroupEventReq to protobuf.
   */
  encode: function (msg) {
    return GetGroupEventReq._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a GetGroupEventReq from protobuf.
   */
  decode: function (bytes) {
    return GetGroupEventReq._readMessage(
      GetGroupEventReq.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a GetGroupEventReq to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(GetGroupEventReq._writeMessageJSON(msg));
  },

  /**
   * Deserializes a GetGroupEventReq from JSON.
   */
  decodeJSON: function (json) {
    return GetGroupEventReq._readMessageJSON(
      GetGroupEventReq.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a GetGroupEventReq with all fields set to their default value.
   */
  initialize: function () {
    return {
      eventID: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.eventID) {
      writer.writeString(1, msg.eventID);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.eventID) {
      json.eventID = msg.eventID;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.eventID = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _eventID = json.eventID;
    if (_eventID) {
      msg.eventID = _eventID;
    }
    return msg;
  },
};

export const AttendeeAvailability = {
  /**
   * Serializes a AttendeeAvailability to protobuf.
   */
  encode: function (msg) {
    return AttendeeAvailability._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a AttendeeAvailability from protobuf.
   */
  decode: function (bytes) {
    return AttendeeAvailability._readMessage(
      AttendeeAvailability.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a AttendeeAvailability to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(AttendeeAvailability._writeMessageJSON(msg));
  },

  /**
   * Deserializes a AttendeeAvailability from JSON.
   */
  decodeJSON: function (json) {
    return AttendeeAvailability._readMessageJSON(
      AttendeeAvailability.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a AttendeeAvailability with all fields set to their default value.
   */
  initialize: function () {
    return {
      availabilityID: "",
      DateRanges: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.availabilityID) {
      writer.writeString(1, msg.availabilityID);
    }
    if (msg.DateRanges?.length) {
      writer.writeRepeatedString(2, msg.DateRanges);
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.availabilityID) {
      json.availabilityID = msg.availabilityID;
    }
    if (msg.DateRanges?.length) {
      json.DateRanges = msg.DateRanges;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.availabilityID = reader.readString();
          break;
        }
        case 2: {
          msg.DateRanges.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _availabilityID = json.availabilityID;
    if (_availabilityID) {
      msg.availabilityID = _availabilityID;
    }
    const _DateRanges = json.DateRanges;
    if (_DateRanges) {
      msg.DateRanges = _DateRanges;
    }
    return msg;
  },
};

export const GetGroupEventRes = {
  /**
   * Serializes a GetGroupEventRes to protobuf.
   */
  encode: function (msg) {
    return GetGroupEventRes._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a GetGroupEventRes from protobuf.
   */
  decode: function (bytes) {
    return GetGroupEventRes._readMessage(
      GetGroupEventRes.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a GetGroupEventRes to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(GetGroupEventRes._writeMessageJSON(msg));
  },

  /**
   * Deserializes a GetGroupEventRes from JSON.
   */
  decodeJSON: function (json) {
    return GetGroupEventRes._readMessageJSON(
      GetGroupEventRes.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a GetGroupEventRes with all fields set to their default value.
   */
  initialize: function () {
    return {
      attendees: [],
      availabilities: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.attendees?.length) {
      writer.writeRepeatedString(1, msg.attendees);
    }
    if (msg.availabilities) {
      writer.writeRepeatedMessage(
        2,
        Object.entries(msg.availabilities).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        GetGroupEventRes.Availabilities._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.attendees?.length) {
      json.attendees = msg.attendees;
    }
    if (msg.availabilities) {
      const availabilities = Object.fromEntries(
        Object.entries(msg.availabilities)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(GetGroupEventRes.Availabilities._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(availabilities).length > 0) {
        json.availabilities = availabilities;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.attendees.push(reader.readString());
          break;
        }
        case 2: {
          const availabilities = {};
          reader.readMessage(
            availabilities,
            GetGroupEventRes.Availabilities._readMessage
          );
          msg.availabilities[availabilities.key] = availabilities.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _attendees = json.attendees;
    if (_attendees) {
      msg.attendees = _attendees;
    }
    const _availabilities = json.availabilities;
    if (_availabilities) {
      msg.availabilities = Object.fromEntries(
        Object.entries(_availabilities)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(GetGroupEventRes.Availabilities._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  Availabilities: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, AttendeeAvailability._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = AttendeeAvailability._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            reader.readMessage(
              AttendeeAvailability.initialize(),
              AttendeeAvailability._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = AttendeeAvailability.initialize();
        AttendeeAvailability._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const UpdateGroupEventReq = {
  /**
   * Serializes a UpdateGroupEventReq to protobuf.
   */
  encode: function (msg) {
    return UpdateGroupEventReq._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes a UpdateGroupEventReq from protobuf.
   */
  decode: function (bytes) {
    return UpdateGroupEventReq._readMessage(
      UpdateGroupEventReq.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Serializes a UpdateGroupEventReq to JSON.
   */
  encodeJSON: function (msg) {
    return JSON.stringify(UpdateGroupEventReq._writeMessageJSON(msg));
  },

  /**
   * Deserializes a UpdateGroupEventReq from JSON.
   */
  decodeJSON: function (json) {
    return UpdateGroupEventReq._readMessageJSON(
      UpdateGroupEventReq.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes a UpdateGroupEventReq with all fields set to their default value.
   */
  initialize: function () {
    return {
      eventID: "",
      attendees: [],
      availabilities: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg, writer) {
    if (msg.eventID) {
      writer.writeString(1, msg.eventID);
    }
    if (msg.attendees?.length) {
      writer.writeRepeatedString(2, msg.attendees);
    }
    if (msg.availabilities) {
      writer.writeRepeatedMessage(
        3,
        Object.entries(msg.availabilities).map(([key, value]) => ({
          key: key,
          value: value,
        })),
        UpdateGroupEventReq.Availabilities._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _writeMessageJSON: function (msg) {
    const json = {};
    if (msg.eventID) {
      json.eventID = msg.eventID;
    }
    if (msg.attendees?.length) {
      json.attendees = msg.attendees;
    }
    if (msg.availabilities) {
      const availabilities = Object.fromEntries(
        Object.entries(msg.availabilities)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(UpdateGroupEventReq.Availabilities._writeMessageJSON)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(availabilities).length > 0) {
        json.availabilities = availabilities;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg, reader) {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.eventID = reader.readString();
          break;
        }
        case 2: {
          msg.attendees.push(reader.readString());
          break;
        }
        case 3: {
          const availabilities = {};
          reader.readMessage(
            availabilities,
            UpdateGroupEventReq.Availabilities._readMessage
          );
          msg.availabilities[availabilities.key] = availabilities.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  /**
   * @private
   */
  _readMessageJSON: function (msg, json) {
    const _eventID = json.eventID;
    if (_eventID) {
      msg.eventID = _eventID;
    }
    const _attendees = json.attendees;
    if (_attendees) {
      msg.attendees = _attendees;
    }
    const _availabilities = json.availabilities;
    if (_availabilities) {
      msg.availabilities = Object.fromEntries(
        Object.entries(_availabilities)
          .map(([key, value]) => ({ key: key, value: value }))
          .map(UpdateGroupEventReq.Availabilities._readMessageJSON)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  Availabilities: {
    /**
     * @private
     */
    _writeMessage: function (msg, writer) {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, AttendeeAvailability._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _writeMessageJSON: function (msg) {
      const json = {};
      if (msg.key) {
        json.key = msg.key;
      }
      if (msg.value) {
        const value = AttendeeAvailability._writeMessageJSON(msg.value);
        if (Object.keys(value).length > 0) {
          json.value = value;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg, reader) {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            reader.readMessage(
              AttendeeAvailability.initialize(),
              AttendeeAvailability._readMessage
            );
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },

    /**
     * @private
     */
    _readMessageJSON: function (msg, json) {
      const _key = json.key;
      if (_key) {
        msg.key = _key;
      }
      const _value = json.value;
      if (_value) {
        const m = AttendeeAvailability.initialize();
        AttendeeAvailability._readMessageJSON(m, _value);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const UpdateGroupEventRes = {
  /**
   * Serializes a UpdateGroupEventRes to protobuf.
   */
  encode: function (_msg) {
    return new Uint8Array();
  },

  /**
   * Deserializes a UpdateGroupEventRes from protobuf.
   */
  decode: function (_bytes) {
    return {};
  },

  /**
   * Serializes a UpdateGroupEventRes to JSON.
   */
  encodeJSON: function (_msg) {
    return "{}";
  },

  /**
   * Deserializes a UpdateGroupEventRes from JSON.
   */
  decodeJSON: function (_json) {
    return {};
  },

  /**
   * Initializes a UpdateGroupEventRes with all fields set to their default value.
   */
  initialize: function () {
    return {};
  },
};
